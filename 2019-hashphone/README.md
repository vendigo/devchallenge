## Як запустити

Через обмеження в 10MB немає можливості викласти зібраний додаток. Тому перед запуском треба його зібрати за допомогою
maven wrapper.

```cmd
mvnw clean package
docker-compose up
```

Проект можна запустити локально без докера, для цього повинна бути запущена MongoDB на localhost:27017.
Відкрити проект в IDE та запустити main class: HashPhoneApplication та активувавши spring.profile=local

При бажанні можна запустити проект на embedded Mongo (Так як це робиться в тестах). Для цього треба в pom.xml 
прибрати test scope у залежності: de.flapdoodle.embed.mongo та закоментити spring.data.mongodb властивості в application.yml 

## Як запустити тести

```cmd
mvnw test
```

Або з IDE: right click на java, 'Run All Tests'

## Опис рішення

### RESTful API

Реалізовані ендпойнти:

* POST /hash - приймає номер телефону як тіло запиту у форматі 380ХХХХХХХ (Присутня валідація). Повертає хеш значення.
* GET /find?hashValue= - приймає хеш значення як параметр запиту. Повертає номер телефону. 
Під час міграції пошук ведеться як по змігрованим так і по не змігрованим даним.
* POST /migration - Створює міграцію, приймає json
* POST /convert - Приймає старий hash повертає новий, працює тільки коли активна міграція.

Для прикладу використання див. Integration тести: MigrationControllerIntTest.java, HashPhoneControllerIntTest.java

### Логіка міграції

Міграція запускається у фоні у вказаний час. Але в деяких випадках вона запускається on demand для конкретних записів:
* Якщо йде запит на кодування телефону а хеш для нього вже присутній в базі
* Якщо йде запит на конвертацію хеш коду

Таким чином користувач гарантовано отримає вже нове значення, навіть якщо фонова міграція ще не дійшла до даного запису.

Якщо міграція закінчилася а користувач не отримував нове значення, 
у нього є можливість користуватися попереднім до наступної міграції.

### Basic Auth

Всі ендпойнти захичені за допомогою Basic Auth. Username: username, Password: password

### Алгоритми хешування

Підтримуються алгоритми SHA-1, SHA-2, SHA-3. Дефолтний алгоритм налаштовується через властивість:
hash.phone.algorithm=SHA-2

### Сіль для хешування

Дефолтна сіль для хешування конфігурується через властивість hash.phone.salt. 

### Обробка хеш колізій

При запиті на хеш телефонного номеру спочатку перевіряється чи він вже присутній в базі. Якшо так, 
повертається збережене значення. Якщо номер відсутній - для нього генерується хеш значення та перевіряєтья що даний хеш
не присутній в базі. Якщо присутній - генерується новий хеш з рандомною сіллю та знову виконується перевірка на унікальність.
Таким чином можливість колізій повністю виключена.

### Unit тести

В проекті наявні Unit тести: PersistenceServiceTest.java, HashingServiceTest.java

### SIT тести

В проекті наявні integration тести реалізовані за допомогою SpringBootTest та Embedded Mongo: HashPhoneControllerIntTest.java,
MigrationControllerIntTest.java

### API Doc

В проекті присутня Swagger документація: resources/open-api.json. Може бути переглянута за допомогою Swagger Online UI:
https://editor.swagger.io/

### Розподілена БД

Для збереження даних використовується MongoDB. Причини: Наявність реактивного драйверу, можливості для масштабування
, створення розподіленого кластеру.

### Логування запитів

Для логування використовується бібліотека Slf4j (див. HashingService.java). User sensitive information логується тільки 
на рівні debug.

### API для отримання метрик системи

Для отримання метрик системи використувується Spring Boot Actuator. Всі доступні ендпойнти можна переглянути за url:
/actuator (Захищено Basic Auth).
Метрики: /actuator/metrics. /actuator/metrics/{metricName}

### Використання Asynchronius non blocking API

Використувується Spring Boot 2+, Spring Web Flux, Reactor, Reactive Mongo driver, Netty embeded server. 
Весь процесс від бази даних до контролера реактивний та non blocking.

## Можливості для покращення

Вибір більш швидкого розподіленого key value storage з підтримкою reactive driver (Наприклад couchbase)
Оптимізація швидкості роботи.
Підтримка https.
Заповнення бази початковими даними.
Написання performance тестів.
Додавання кешування у HashContextService
